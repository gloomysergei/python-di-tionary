# Операции над множествами

## Сравнение множеств в Python

В Python два множества считаются равными, если содержат одинаковые элементы, вне зависимости от порядка.

Чтобы сравнить совпадают ли все элементы одного множества со вторым, применяется оператор `==`.
Если множества равны друг другу, то возвращается булевое значение `True`, в противном случае - `False`.

### Пример 1

Давайте сравним два множества:

```python
st1 = {1, 2, 3, 4}
st2 = {2, 1, 3, 4}

print(st1 == st2) # выведет True
```

### Пример 2

```python
st1 = {8, 6, 4, 2}
st2 = {5, 8, 2, 4}

print(st1 == st2) # выведет False
```

## Оъединение множеств - метод union

`union [ˈju:njən]` [произношение](https://www.translate.ru/перевод/английский-русский/union)

Метод `union` возвращает множество, полученное при объединении элементов множеств, указанных в параметре.

### Синтаксис

`множество.union(множества, которые хотим объединить)`

### Пример

Получение общих элементов для двух множеств:

```python
st1 = {'a', 'b', 'c'}
st2 = {'1', '2', '3'}
res = st1.union(st2)
print(res) # {'c', '2', 'b', '1', 'a', '3'}
```

### Пример

У метода `union` также есть короткая форма:

```python
st1 = {'a', 'b', 'c'}
st2 = {'1', '2', '3'}
res = st1 | st2
print(res) # {'a', '1', 'b', '3', '2', 'c'}
```

## Метод intersection

`intersection [ɪntəˈsekʃən]` [произношение](https://www.translate.ru/перевод/английский-русский/intersection)

Метод `intersection` осуществляет пересечение нескольких множеств, в результате чего возвращает новое множество с общими для указанных множеств элементами. В параметре метода передаем множество, для которого хотим узнать общие элементы.

### Синтаксис

`множество.intersection(множество, с которым хотим найти общие элементы)`

### Пример

Получение общих элементов для двух множеств:

```python
st1 = {'a', 'b', 'c'}
st2 = {'e', 'f', 'c', 'a'}
res = st1.intersection(st2)
print(res) ## {'c', 'a'}
```

### Пример

У метода `intersection` также есть короткая форма:

```python
st1 = {'a', 'b', 'c'}
st2 = {'e', 'f', 'c', 'a'}
res = st1 & st2
print(res) # {'c', 'a'}
```

## Метод difference

`difference [ˈdɪfrəns]` [Произношение](https://www.translate.ru/перевод/английский-русский/difference)

Разность множеств `(difference)` — такое множество, элементы которого содержатся в первом оригинальном множестве, но не содержатся во втором.

Метод `difference` возвращает множество, полученное из элементов, по которым первое множество отличается от второго. В параметре указываем множество, с которым хотим сравнить исходное.

### Синтаксис

`множество.difference(множество, с которым хотим сравнить)`

### Пример

Получение разных элементов двух множеств:

```python
st1 = {'a', 'b', 'c'}
st2 = {'e', 'g', 'a'}
res = st1.difference(st2)
print(res) # {'c', 'b'}
```

### Пример

У метода `difference` также есть короткая форма:

```python
st1 = {'a', 'b', 'c'}
st2 = {'e', 'g', 'a'}
res = st1 - st2
print(res) # {'b', 'c'}
```

## Метод `symmetric_difference`

`symmetric [sɪˈmetrɪk]`

Симметрическая разность `(symmetric difference)` — множество, в которое входят элементы, присутствующие ЛИБО в первом, ЛИБО во втором оригинальном множестве.

По смыслу операция похожа на исключающее `ИЛИ (xor)`, поэтому и представлена оператором `^`:

```python
visited_by_masha = {"Paris", "London"}
visited_by_kolya = {"Moscow", "Paris"}
visited_by_kolya ^ visited_by_masha  # {'London', 'Moscow'}
```

Метод `symmetric_difference`:

- исключает общие элементы для множества и последовательности,
- при этом возвращает новое множество, в котором находятся только отличающиеся элементы.
- В параметре указываем множество, с которым хотим сравнить исходное.

### Синтаксис

`множество.symmetric_difference(множество, с которым хотим сравнить)`

### Пример

Получение различающихся элементов для двух множеств:

```python
st1 = {'a', 'b', 'c'}
st2 = {'e', 'g', 'a'}
res = st1.symmetric_difference(st2)
print(res) # {'g', 'b', 'c', 'e'}
```

### Пример

У метода `symmetric_difference` также есть короткая форма:

```python
st1 = {'a', 'b', 'c'}
st2 = {'e', 'g', 'a'}
res = st1 ^ st2
print(res) # {'g', 'c', 'b', 'e'}
```

## Подмножества и надмножества

Одно множество является **подмножеством** другого `(subset)`, если все элементы первого входят во второе, но второе может содержать еще и другие элементы.

Второе в этом случае является **надмножеством** для первого `(superset)`

## Метод issubset

Метод `issubset` проверяет вхождение элементов множества в последовательности, которой может быть другое множество, список, кортеж.
Метод возвращает булевое значение - True или False.
В параметре указываем последовательность, с которой хотим сравнить элементы множества.

### Синтаксис

`множество.issubset(последовательность)`

### Пример

Давайте проверим вхождение элементов первого множества во второе помощью метода `issubset`:

```python
st1 = {'a', 'b', 'c'}
st2 = {'e', 'g', 'a'}
res = st1.issubset(st2)
print(res) # False
```

### Пример

А теперь давайте снова проверим вхождение элементов с помощью метода issubset:

```python
st1 = {'a', 'b', 'c'}
st2 = {'a', 'b', 'c'}
res = st1.issubset(st2)
print(res) # True
```

### Пример

Давайте сравним элементы множества с элементами списка:

```python
st = {'a', 'b', 'c'}
lst = ['a', 'b', 'c']
res = st.issubset(lst)
print(res) # True
```

### Пример

А теперь давайте сравним элементы множества с кортежем:

```python
st = {'a', 'b', 'c'}
tlp = ('a', 'b', 'c')
res = st.issubset(tlp)
print(res) #True
```

### Пример

У метода `issubset` также есть короткая форма:

```python
st1 = {'a', 'b', 'c'}
st2 = {'a', 'b', 'c'}
res = st1 <= st2
print(res) #True
```

## Метод issuperset

Метод `issuperset` проверяет вхождение элементов последовательности в множество.
Метод возвращает булевое значение - True или False.
В параметре указываем последовательность, с которой хотим сравнить элементы множества.

### Синтаксис

`множество.issuperset(последовательность)`

### Пример

Давайте проверим вхождение элементов второго множества в первое с помощью метода `issuperset`:

```python
st1 = {'a', 'b', 'c'}
st2 = {'e', 'g', 'a'}
res = st1.issuperset(st2)
print(res) #False
```

### Пример

А теперь давайте снова проверим вхождение элементов с помощью метода `issuperset`:

```python
st1 = {'a', 'b', 'c'}
st2 = {'a', 'b', 'c'}
res = st1.issuperset(st2)
print(res) # True
```

### Пример

Давайте сравним элементы списка с элементами множества:

```python
st = {'a', 'b', 'c'}
lst = ['a', 'b', 'c']
res = st.issuperset(lst)
print(res) # True
```

### Пример

А теперь давайте сравним элементы кортежа с множеством:

```python
st = {'a', 'b', 'c'}
tlp = ('a', 'b', 'c')
res = st.issuperset(tlp)
print(res) # True
```

### Пример

У метода `issuperset` также есть короткая форма:

```python
st1 = {'a', 'b', 'c'}
st2 = {'e', 'g', 'a'}
res = st1 >= st2
print(res) # False
```

# src/solution.py

Выполнить анализ изменений в старой и новой версии словаря.
Вам нужно реализовать функцию `diff_keys()`, которая должна:

1. Принимать два словаря-аргумента — старый и новый
2. Возвращать словарь с результатами анализа
3. Результирующий словарь должен содержать строго три ниже перечисленных ключа:

- `'kept'` — множество ключей, которые присутствовали в старом словаре и остались в новом
- `'added'` — множество ключей, которые отсутствовали в старом словаре, но появились в новом
- `'removed'` — множество ключей, которые присутствовали в старом словаре, но в новый не вошли
  Обратите внимание, что в этом упражнении сравниваются только ключи, а не значения.

```python
diff_keys({'name': 'Bob', 'age': 42}, {})
# {'kept': set(), 'added': set(), 'removed': {'name', 'age'}}
diff_keys({}, {'name': 'Bob', 'age': 42})
# {'kept': set(), 'added': {'name', 'age'}, 'removed': set()}
diff_keys({'a': 2}, {'a': 1})
# {'kept': {'a'}, 'added': set(), 'removed': set()}
```
