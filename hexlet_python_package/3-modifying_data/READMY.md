# Изменение данных в словаре

## Метод `pop`

Метод `pop` удаляет элемент из словаря по его ключу и и возвращает его значение.
При попытке извлечь значение по не существующему ключу - выброс исключения.
При использовании значения по умолчанию - выброса исключения не будет

- в первом параметре метода задаем ключ элемента,
- во втором необязательном параметре - значение по умолчанию.

```
dictionary.pop(ключ, [значение по умолчанию])
```

## Метод `popitem`

Метод `popitem` удаляет пару ключ-значение с конца словаря, при этом возвращая кортеж из удаленной пары. В параметре метода ничего не задаем.

```
list.popitem()
```

### Пример

```
dct = {
	'a': 1,
	'b': 2,
	'c': 3
}

print(dct.popitem())
print(dct)

# ('c', 3)
# {'a': 1, 'b': 2}
```

## Метод `update`

Метод `update` дополняет исходный словарь ключами и значениями другого словаря. В параметре метода указываем словарь, которым дополним исходный.
Происходит не только добавление но и обновление данных:

- Новые ключи дописываются в словарь
- Если какие-то ключи уже существовали до этого, то связанные с ними значения будут заменены новыми

```
cart = {"apples": 2, "oranges": 1}
addon = {"oranges": 5, "lemons": 3}
cart.update(addon)
cart  # {"apples": 2, "oranges": 5, "lemons": 3}
```

## Метод `copy`

Метод `copy` работает как копирование **списка** с помощью среза `[:]`.
При вызове метод возвращает поверхностную копию словаря - `shallow copy`.
Поверхностная копия копирует только структуру словаря:

- не копирует значения
- только создает на этих значениях новые ссылки

```
d = {"a": 1, "b": [42]}
c = d.copy()
c.update({"a": 10, "1k": 1024})
c  # {"a": 10, "b": [42], "1k": 1024}
c["b"].append(None)
c  # {"a": 10, "b": [42, None], "1k": 1024}
d  # {"a": 1, "b": [42, None]}
```

## Метод `clear`

Происходит полная очистка словаря
Метод clear() удаляет все элементы из текущего словаря:

```
d = {"a": 1}
d.clear()
d  # {}
```

Очистка списка можно делать с помощью среза `list[:] = []`

## Задача

### src/solution.py

Цель упражнения — функция `count_all()`. Эта функция должна принимать на вход итерируемый источник и возвращать словарь. Ключами этого словаря должны стать элементы источника, при этом значения должны отражать количество повторов элемента в коллекции-источнике.

Посмотрим на этих примерах, как должна работать эта функция:

```
count_all(["cat", "dog", "cat"])  # {"cat": 2, "dog": 1}
count_all("hello")  # {'h': 1, 'e': 1, 'l': 2, 'o': 1}
count_all("*" * 20)  # {'*': 20}
```

## Решение

1. Необходимо в коллекции данных определить количество вхождений элементов коллекции.
2. Сделал с помощью вложенных циклов
3. Решение цчителя - использование `get`

> Метод `get` возвращает значение словаря по ключу.

- В случае, если данный ключ отсутствует - значение по умолчанию.
- В первом параметре метода указываем нужный нам ключ,
- во втором необязательном параметре - значение по умолчанию.
